expression ::= @_ assignment :captured #captured_something
;

assignment ::=
  @_ conditional
  [ ['=' #nnary_op("binary", "left", "right") ] :op conditional]*
;

constant ::= @_ conditional
;

conditional ::=
  @_ add
  [
    ['?' #nnary_op("ternary", "condition", "then")] :op
    [add]?
    ':'
    @next("else")
    [add]?
  ]?
;

add ::=
  @_ mul [ [ ['+'| '-'] #nnary_op("binary", "left", "right") ] :op mul ]*
;

mul ::=
  @_ unary [ [ ['/'| '*' | '%'] #nnary_op("binary", "left", "right") ] :op unary ]*
;

unary ::=
  [
    @_ postfix #sizeof
    | 
    @_
    [
      [
        ['-' | '&' | '*' | "++" | "--"] :op #type_next("unary", "subexpr")
        | '(' type_name :op ')' #type_next("cast", "subexpr")
      ]
      unary 
    ]?
  ]
;

postfix ::=
  @_ primary
  [
      '['  #to_post_expr("index") add ']' 
    | '('  #to_post_expr("call") add ')' 
    | ['.' | "->"] :op  #to_post_op("struct") struct_postfix
  ]*
  [ ["++" | "--"] :op #to_post_op("operator") ]?
;

type_name ::= ["void" | "char"| "int"] :type_name
;

struct_postfix ::= #identifier :struct_id
;

primary ::=
    #num :primary #primary("primary")
    | #identifier :primary_id #primary("id")
    | '(' ![type_name] #type_next("parenthesis", "body") add ')'
;
